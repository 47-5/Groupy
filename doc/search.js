window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "groupy", "modulename": "groupy", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_calculator", "modulename": "groupy.gp_calculator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_calculator.Calculator", "modulename": "groupy.gp_calculator", "qualname": "Calculator", "kind": "class", "doc": "<p>A Class for calculating properties of given molecules based on the group contribution method</p>\n"}, {"fullname": "groupy.gp_calculator.Calculator.loader", "modulename": "groupy.gp_calculator", "qualname": "Calculator.loader", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_calculator.Calculator.counter", "modulename": "groupy.gp_calculator", "qualname": "Calculator.counter", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_calculator.Calculator.parameters_step_wise", "modulename": "groupy.gp_calculator", "qualname": "Calculator.parameters_step_wise", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_calculator.Calculator.parameters_simultaneous", "modulename": "groupy.gp_calculator", "qualname": "Calculator.parameters_simultaneous", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_calculator.Calculator.Tm", "modulename": "groupy.gp_calculator", "qualname": "Calculator.Tm", "kind": "function", "doc": "<p>Calculating the freezing (melting) point. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.Tb", "modulename": "groupy.gp_calculator", "qualname": "Calculator.Tb", "kind": "function", "doc": "<p>Calculating the boiling point. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.Tc", "modulename": "groupy.gp_calculator", "qualname": "Calculator.Tc", "kind": "function", "doc": "<p>Calculating the critical temperature. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.Pc", "modulename": "groupy.gp_calculator", "qualname": "Calculator.Pc", "kind": "function", "doc": "<p>Calculating the critical pressure. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.Vc", "modulename": "groupy.gp_calculator", "qualname": "Calculator.Vc", "kind": "function", "doc": "<p>Calculating the critical volume. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.delta_Gf", "modulename": "groupy.gp_calculator", "qualname": "Calculator.delta_Gf", "kind": "function", "doc": "<p>Calculating the Gibbs free energy. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.delta_Hf", "modulename": "groupy.gp_calculator", "qualname": "Calculator.delta_Hf", "kind": "function", "doc": "<p>Calculating the enthalpy of formation. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.delta_Hv", "modulename": "groupy.gp_calculator", "qualname": "Calculator.delta_Hv", "kind": "function", "doc": "<p>Calculating the enthalpy of vaporization. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.delta_Hfus", "modulename": "groupy.gp_calculator", "qualname": "Calculator.delta_Hfus", "kind": "function", "doc": "<p>Calculating the enthalpy of fusion. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.flash_point", "modulename": "groupy.gp_calculator", "qualname": "Calculator.flash_point", "kind": "function", "doc": "<p>Calculating the flash point. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.molar_volume", "modulename": "groupy.gp_calculator", "qualname": "Calculator.molar_volume", "kind": "function", "doc": "<p>Calculating the liquid molar volume. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>group_number</strong>:  number of different groups in a given molecule.\nIn general, users can use the result of groupy.gp_counter.Counter.count_a_mol()</li>\n<li><strong>parameters</strong>:  parameters used in group contribution method.\nIn general, users can use internal data of groupy that can be loaded by groupy.gp_loader.Loader</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">group_number</span>, </span><span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.density", "modulename": "groupy.gp_calculator", "qualname": "Calculator.density", "kind": "function", "doc": "<p>Calculating the density. When user call Calculator.calculate_a_mol(), this method will be called automatically.\nIn general, users do not need to call this function themselves.\ndensity = Mw / molar volume</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>molar_mass</strong>:  molar mass.</li>\n<li><strong>Vm</strong>:  molar volume.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">molar_mass</span>, </span><span class=\"param\"><span class=\"n\">Vm</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.delta_Hc", "modulename": "groupy.gp_calculator", "qualname": "Calculator.delta_Hc", "kind": "function", "doc": "<p>Calculating the enthalpy of combustion. When user call Calculator.calculate_a_mol(), this method will be called automatically if the molecule is a hydrocarbon compound.\nIn general, users do not need to call this function themselves.\nAttention: This function was written with only hydrocarbons in mind, and the result of this function must be wrong when the molecule contains other heteroatoms (such as F, Cl, S...). When Calculator.calculate_a_mol() is called, Calculator.calculate_a_mol() will determine if the molecule to be calculated is a hydrocarbon molecule, and if not, it will automatically return None</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>C_number</strong>:  number of different groups in a given molecule.</li>\n<li><strong>H_number</strong>:  parameters used in group contribution method.</li>\n<li><strong>delta_Hf</strong>:  Enthalpy of formation.\nIn general, users can use output of Calculator.delta_Hf().</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">C_number</span>, </span><span class=\"param\"><span class=\"n\">H_number</span>, </span><span class=\"param\"><span class=\"n\">delta_Hf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.q", "modulename": "groupy.gp_calculator", "qualname": "Calculator.q", "kind": "function", "doc": "<p>Calculating the heat value. When user call Calculator.calculate_a_mol(), this method will be called automatically if the molecule is a hydrocarbon compound.\nIn general, users do not need to call this function themselves.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>delta_Hc</strong>:  enthalpy of combustion.</li>\n<li><strong>molar_mass</strong>:  molar mass.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">delta_Hc</span>, </span><span class=\"param\"><span class=\"n\">molar_mass</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.isp", "modulename": "groupy.gp_calculator", "qualname": "Calculator.isp", "kind": "function", "doc": "<p>Calculating the Specific impulse(isp). When user call Calculator.calculate_a_mol(), this method will be called automatically if the molecule is a hydrocarbon compound.\nIn general, users do not need to call this function themselves.\nAttention: This function was written with only hydrocarbons in mind, and the result of this function must be wrong when the molecule contains other heteroatoms (such as F, Cl, S...). When Calculator.calculate_a_mol() is called, Calculator.calculate_a_mol() will determine if the molecule to be calculated is a hydrocarbon molecule, and if not, it will automatically return None</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>C_number</strong>:  number of different groups in a given molecule.</li>\n<li><strong>H_number</strong>:  parameters used in group contribution method.</li>\n<li><strong>q</strong>:  heat value.\nIn general, users can use output of Calculator.q() if the molecule is a hydrocarbon compound.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">C_number</span>, </span><span class=\"param\"><span class=\"n\">H_number</span>, </span><span class=\"param\"><span class=\"n\">q</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.C_number", "modulename": "groupy.gp_calculator", "qualname": "Calculator.C_number", "kind": "function", "doc": "<p>Counting number of C atoms in a molecule.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.H_number", "modulename": "groupy.gp_calculator", "qualname": "Calculator.H_number", "kind": "function", "doc": "<p>Counting number of H atoms in a molecule.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>int</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.smiles", "modulename": "groupy.gp_calculator", "qualname": "Calculator.smiles", "kind": "function", "doc": "<p>return SMILES of a molecule.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>str</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.molar_mass", "modulename": "groupy.gp_calculator", "qualname": "Calculator.molar_mass", "kind": "function", "doc": "<p>Calculating molar mass of a molecule.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>float</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.is_hydrocarbon", "modulename": "groupy.gp_calculator", "qualname": "Calculator.is_hydrocarbon", "kind": "function", "doc": "<p>Determine whether a molecule is a hydrocarbon compound</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>bool</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.calculate_a_mol", "modulename": "groupy.gp_calculator", "qualname": "Calculator.calculate_a_mol", "kind": "function", "doc": "<p>Calculating properties of a molecule.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol or SMILES str which will be converter to rdkit.Chem.rdchem.Mol automatically.</li>\n<li><strong>debug</strong>:  bool. If set to be True, Calculator will print the results of Counter on screen. Default=False</li>\n<li><strong>check_hydrocarbon</strong>:  bool. Since Calculator.delta_Hc() was designed for hydrocarbon, if set to True, Calculator will check whether the molecule is hydrocarbon.\nIf the molecule is not hydrocarbon, Calculator will not calculate delta_Hc, q and ISP. If set to False, Calculator will calculate these properties no matter whether the molecule is hydrocarbon.\nDefault=True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>dict like {'smiles': init_smi,\n              'molar_mass': value,\n              'flash_point/K': value,\n              'Tm/K': value, 'Tb/K': value, 'Tc/K': value,\n              'Pc/bar': value, 'Vc/(cm3/mol)': value,\n              'density/(g/cm3)': value,\n              'delta_G/(KJ/mol)': value,\n              'delta_Hf/(KJ/mol)': value,\n              'delta_Hvap/(KJ/mol)': value,\n              'delta_Hfus/(KJ/mol)': value,\n              'molar_volume/(cm3/mol)(default298K)': value,\n              'delta_Hc/(KJ/mol)': value,\n              'mass_calorific_value_h/(MJ/kg)': value,\n              'ISP': value,\n              'note': value}</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">mol</span>,</span><span class=\"param\">\t<span class=\"n\">parameter_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;step_wise&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">check_hydrocarbon</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.calculate_mols", "modulename": "groupy.gp_calculator", "qualname": "Calculator.calculate_mols", "kind": "function", "doc": "<p>Calculating properties of a batch of molecules.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  path of the file(.txt, .xlsx, .csv) in which saved SMILES.</li>\n<li><strong>properties_file_path: path of result file. default</strong>:  'gp_3x_result.csv'</li>\n<li><strong>check_hydrocarbon</strong>:  bool. Since Calculator.delta_Hc() was designed for hydrocarbon, if set to True, Calculator will check whether the molecule is hydrocarbon.\nIf the molecule is not hydrocarbon, Calculator will not calculate delta_Hc, q and ISP. If set to False, Calculator will calculate these properties no matter whether the molecule is hydrocarbon.\nDefault=True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>instance of pandas.DataFrame</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">smiles_file_path</span>,</span><span class=\"param\">\t<span class=\"n\">properties_file_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;gp_3x_result.csv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">check_hydrocarbon</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">parameter_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;simultaneous&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_calculator.Calculator.calculate_mols_mpi", "modulename": "groupy.gp_calculator", "qualname": "Calculator.calculate_mols_mpi", "kind": "function", "doc": "<p>Calculating properties of a batch of molecules with MPI acceleration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  path of the file(.txt, .xlsx, .csv) in which saved SMILES.</li>\n<li><strong>properties_file_path: path of result file. default</strong>:  'gp_3x_result.csv'</li>\n<li><strong>check_hydrocarbon</strong>:  bool. Since Calculator.delta_Hc() was designed for hydrocarbon, if set to True, Calculator will check whether the molecule is hydrocarbon.\nIf the molecule is not hydrocarbon, Calculator will not calculate delta_Hc, q and ISP. If set to False, Calculator will calculate these properties no matter whether the molecule is hydrocarbon.\nDefault=True.</li>\n<li><strong>n_jobs</strong>:  int. Number of cores. Default=1</li>\n<li><strong>batch_size</strong>:  int. Task number per core. default='auto'</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>instance of pandas.DataFrame</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">smiles_file_path</span>,</span><span class=\"param\">\t<span class=\"n\">properties_file_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;gp_3x_result_mpi.csv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">check_hydrocarbon</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">parameter_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;simultaneous&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">n_jobs</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor", "modulename": "groupy.gp_convertor", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_convertor.Convertor", "modulename": "groupy.gp_convertor", "qualname": "Convertor", "kind": "class", "doc": "<p>A class for converting between SMILES and different file formats (such as xyz, pdb, gro...). Users can call\nConvertor.plot_supported_format() to print all supported file formats.</p>\n"}, {"fullname": "groupy.gp_convertor.Convertor.smi_to_xyz", "modulename": "groupy.gp_convertor", "qualname": "Convertor.smi_to_xyz", "kind": "function", "doc": "<p>Converting SMILES to xyz file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smi</strong>:  str. SMILES of a molecule</li>\n<li><strong>xyz_path</strong>:  str. Path of xyz file you want to generate. Default={smi}.xyz</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>bool. True if the xyz file is successfully generated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">smi</span>, </span><span class=\"param\"><span class=\"n\">xyz_path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.batch_smi_to_xyz", "modulename": "groupy.gp_convertor", "qualname": "Convertor.batch_smi_to_xyz", "kind": "function", "doc": "<p>Converting a batch of SMILES to xyz files.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  str. Path of the file in which saved SMILES.</li>\n<li><strong>xyz_root_path</strong>:  str. The folder path where all generated xyz files are saved.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">smiles_file_path</span>, </span><span class=\"param\"><span class=\"n\">xyz_root_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.batch_smi_to_xyz_mpi", "modulename": "groupy.gp_convertor", "qualname": "Convertor.batch_smi_to_xyz_mpi", "kind": "function", "doc": "<p>Converting a batch of SMILES to xyz files with MPI acceleration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  str. Path of the file in which saved SMILES.</li>\n<li><strong>xyz_root_path</strong>:  str. The folder path where all generated xyz files are saved.</li>\n<li><strong>n_jobs</strong>:  int. number of CPU cores you want to use when generating xyz file.</li>\n<li><strong>batch_size</strong>:  int or str. Number of tasks per CPU core you want to use when generating xyz file. Default='auto'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">smiles_file_path</span>, </span><span class=\"param\"><span class=\"n\">xyz_root_path</span>, </span><span class=\"param\"><span class=\"n\">n_jobs</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.convert_file_type", "modulename": "groupy.gp_convertor", "qualname": "Convertor.convert_file_type", "kind": "function", "doc": "<p>Converting file format.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>in_format</strong>:  str. Init format.</li>\n<li><strong>in_path</strong>:  str. Init file path.</li>\n<li><strong>out_format</strong>:  str. Target format.</li>\n<li><strong>out_path</strong>:  str. Target file path. If set to None, out_path will be same as in_path except its suffix.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">in_format</span>, </span><span class=\"param\"><span class=\"n\">in_path</span>, </span><span class=\"param\"><span class=\"n\">out_format</span>, </span><span class=\"param\"><span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.batch_convert_file_type", "modulename": "groupy.gp_convertor", "qualname": "Convertor.batch_convert_file_type", "kind": "function", "doc": "<p>Converting format of a batch of files.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>in_format</strong>:  str. Init format.</li>\n<li><strong>in_root_path</strong>:  str. Path of the folder in which save files that you want to change format.</li>\n<li><strong>out_format</strong>:  str. Target format.</li>\n<li><strong>out_root_path</strong>:  str. Path of the folder where all new files are saved. If set to None, out_root_path will be same as in_root_path.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">in_format</span>, </span><span class=\"param\"><span class=\"n\">in_root_path</span>, </span><span class=\"param\"><span class=\"n\">out_format</span>, </span><span class=\"param\"><span class=\"n\">out_root_path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.batch_convert_file_type_mpi", "modulename": "groupy.gp_convertor", "qualname": "Convertor.batch_convert_file_type_mpi", "kind": "function", "doc": "<p>Converting format of a batch of files with MPI acceleration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>in_format</strong>:  str. Init format.</li>\n<li><strong>in_root_path</strong>:  str. Path of the folder in which save files that you want to change format.</li>\n<li><strong>out_format</strong>:  str. Target format.</li>\n<li><strong>out_root_path</strong>:  str. Path of the folder where all new files are saved. If set to None, out_root_path will be same as in_root_path.</li>\n<li><strong>n_jobs</strong>:  int. number of CPU cores you want to use when converting file format.</li>\n<li><strong>batch_size</strong>:  int or str. Number of tasks per CPU core you want to use when converting file format. Default='auto'.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">in_format</span>,</span><span class=\"param\">\t<span class=\"n\">in_root_path</span>,</span><span class=\"param\">\t<span class=\"n\">out_format</span>,</span><span class=\"param\">\t<span class=\"n\">out_root_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_jobs</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.file_to_smi", "modulename": "groupy.gp_convertor", "qualname": "Convertor.file_to_smi", "kind": "function", "doc": "<p>Converting a file into SMILES.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file_path</strong>:  str. Path of the file.</li>\n<li><strong>format</strong>:  str. Format of the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>SMILES</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span>, </span><span class=\"param\"><span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.batch_file_to_smi", "modulename": "groupy.gp_convertor", "qualname": "Convertor.batch_file_to_smi", "kind": "function", "doc": "<p>Converting a batch of files into SMILES.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>in_format</strong>:  str. Format of the file.</li>\n<li><strong>in_root_path</strong>:  str. Path of the folder in which save files that you want to convert to SMILES.</li>\n<li><strong>out_root_path</strong>:  str. Path of the folder in which save the file that save SMILES of molecules.\nIf set to None, out_root_path will be same as in_root_path.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">in_format</span>, </span><span class=\"param\"><span class=\"n\">in_root_path</span>, </span><span class=\"param\"><span class=\"n\">out_root_path</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.batch_file_to_smi_mpi", "modulename": "groupy.gp_convertor", "qualname": "Convertor.batch_file_to_smi_mpi", "kind": "function", "doc": "<p>Converting a batch of files into SMILES with MPI acceleration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>in_format</strong>:  str. Format of the file.</li>\n<li><strong>in_root_path</strong>:  str. Path of the folder in which save files that you want to convert to SMILES.</li>\n<li><strong>out_root_path</strong>:  str. Path of the folder in which save the file that save SMILES of molecules.\nIf set to None, out_root_path will be same as in_root_path.</li>\n<li><strong>n_jobs</strong>:  int. number of CPU cores you want to use when converting file to SMILES.</li>\n<li><strong>batch_size</strong>:  int or str. Number of tasks per CPU core you want to use when converting file to SMILES. Default='auto'.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">in_format</span>,</span><span class=\"param\">\t<span class=\"n\">in_root_path</span>,</span><span class=\"param\">\t<span class=\"n\">out_root_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_jobs</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_convertor.Convertor.plot_supported_format", "modulename": "groupy.gp_convertor", "qualname": "Convertor.plot_supported_format", "kind": "function", "doc": "<p>print all supported file formats.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_counter", "modulename": "groupy.gp_counter", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_counter.Counter", "modulename": "groupy.gp_counter", "qualname": "Counter", "kind": "class", "doc": "<p>A class for counting number of different groups in molecule.</p>\n"}, {"fullname": "groupy.gp_counter.Counter.loader", "modulename": "groupy.gp_counter", "qualname": "Counter.loader", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_counter.Counter.init_result", "modulename": "groupy.gp_counter", "qualname": "Counter.init_result", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_counter.Counter.result", "modulename": "groupy.gp_counter", "qualname": "Counter.result", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_counter.Counter.f_order_group_function", "modulename": "groupy.gp_counter", "qualname": "Counter.f_order_group_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_counter.Counter.s_order_group_function", "modulename": "groupy.gp_counter", "qualname": "Counter.s_order_group_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_counter.Counter.t_order_group_function", "modulename": "groupy.gp_counter", "qualname": "Counter.t_order_group_function", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_counter.Counter.count_a_mol", "modulename": "groupy.gp_counter", "qualname": "Counter.count_a_mol", "kind": "function", "doc": "<p>Counting number of different groups of a molecule.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol or SMILES str which will be converter to rdkit.Chem.rdchem.Mol automatically.</li>\n<li><strong>clear_mode</strong>:  bool. If set to True, The dictionary that stores the results will only retain groups with a count that is not zero. Default=False.</li>\n<li><strong>add_note: bool. If set to True, a note(SMILES of current molecule) will be added to the dictionary that stores the results, i.e. {note</strong>:  SMILES}. Default=False.</li>\n<li><strong>add_smiles: bool. If set to True, The SMILES of current molecule will be added to the dictionary that stores the results, i.e. {smiles</strong>:  SMILES}. Default=False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dict. A dictionary that stores the results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"n\">clear_mode</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">add_note</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">add_smiles</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_counter.Counter.count_mols", "modulename": "groupy.gp_counter", "qualname": "Counter.count_mols", "kind": "function", "doc": "<p>Counting number of different groups of a batch of molecules.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  str. Path of the file(.txt, .xlsx, .csv) in which saved SMILES of molecules.</li>\n<li><strong>count_result_file_path</strong>:  str. path of result file. Default='count_result.csv'.</li>\n<li><strong>add_note: bool. If set to True, a note(SMILES of current molecule) will be added to the dictionary that stores the results, i.e. {note</strong>:  SMILES}. Default=False.</li>\n<li><strong>add_smiles: bool. If set to True, The SMILES of current molecule will be added to the dictionary that stores the results, i.e. {smiles</strong>:  SMILES}. Default=False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pandas Dataframe. A dictionary that stores the results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">smiles_file_path</span>,</span><span class=\"param\">\t<span class=\"n\">count_result_file_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;count_result.csv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_note</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">add_smiles</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_counter.Counter.count_mols_mpi", "modulename": "groupy.gp_counter", "qualname": "Counter.count_mols_mpi", "kind": "function", "doc": "<p>Counting number of different groups of a batch of molecules with MPI acceleration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  str. Path of the file(.txt, .xlsx, .csv) in which saved SMILES of molecules.</li>\n<li><strong>count_result_file_path</strong>:  str. path of result file. Default='count_result.csv'.</li>\n<li><strong>add_note: bool. If set to True, a note(SMILES of current molecule) will be added to the dictionary that stores the results, i.e. {note</strong>:  SMILES}. Default=False.</li>\n<li><strong>add_smiles: bool. If set to True, The SMILES of current molecule will be added to the dictionary that stores the results, i.e. {smiles</strong>:  SMILES}. Default=False.</li>\n<li><strong>n_jobs</strong>:  int. number of CPU cores you want to use when counting groups.</li>\n<li><strong>batch_size</strong>:  int or str. Number of tasks per CPU core you want to use when counting groups. Default='auto'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>pandas Dataframe. A dictionary that stores the results.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">smiles_file_path</span>,</span><span class=\"param\">\t<span class=\"n\">count_result_file_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;count_result.csv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_note</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">add_smiles</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">n_jobs</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_counter.Counter.get_group_fingerprint", "modulename": "groupy.gp_counter", "qualname": "Counter.get_group_fingerprint", "kind": "function", "doc": "<p>Getting group style fingerprint of a molecule. In fact, this method just call Counter.count_a_mol() and convert its result to a list.\nIf users want to get fingerprint of a batch of molecules, they can use Counter.count_mols() or Counter.count_mols_mpi().</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  instance of rdkit.Chem.rdchem.Mol or SMILES str which will be converter to rdkit.Chem.rdchem.Mol automatically.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>list. e.g. [1,2,0,0,.....]</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_counter.Counter.count_1st_order_groups", "modulename": "groupy.gp_counter", "qualname": "Counter.count_1st_order_groups", "kind": "function", "doc": "<p>counting number of 1st order groups. In general, users do not need to use this method since this method will be called when Counter.count_a_mol, Counter.count_mols, Counter.count_mols_mpi are called.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"n\">add_note</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_counter.Counter.count_2nd_order_groups", "modulename": "groupy.gp_counter", "qualname": "Counter.count_2nd_order_groups", "kind": "function", "doc": "<p>counting number of 2nd order groups. In general, users do not need to use this method since this method will be called when Counter.count_a_mol, Counter.count_mols, Counter.count_mols_mpi are called.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_counter.Counter.count_3rd_order_groups", "modulename": "groupy.gp_counter", "qualname": "Counter.count_3rd_order_groups", "kind": "function", "doc": "<p>counting number of 3rd order groups. In general, users do not need to use this method since this method will be called when Counter.count_a_mol, Counter.count_mols, Counter.count_mols_mpi are called.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator", "modulename": "groupy.gp_generator", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_generator.Generator", "modulename": "groupy.gp_generator", "qualname": "Generator", "kind": "class", "doc": "<p>A Class for generating Gaussian Job File (gjf)</p>\n"}, {"fullname": "groupy.gp_generator.Generator.calculate_charge", "modulename": "groupy.gp_generator", "qualname": "Generator.calculate_charge", "kind": "function", "doc": "<p>Calculating net charge (all proton - all charge) and all charge.\nThis method is used to calculate net charge which is used to generate gjf file.\nGenerator.calculate_multiplicity() also call this method to calculate multiplicity.\nIn general, users do not need to use this method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smi</strong>:  SMILES str or instance of rdkit.Chem.rdchem.Mol</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(int, int). (net charge, all charge)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">smi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator.Generator.calculate_multiplicity", "modulename": "groupy.gp_generator", "qualname": "Generator.calculate_multiplicity", "kind": "function", "doc": "<p>Calculating multiplicity to generate gjf files.\nGenerator.calculate_multiplicity() also call this method to calculate multiplicity.\nIn general, users do not need to use this method. We also do not recommend users to explicitly use this\nfunction for calculating the multiplicity of their choice, as this method only considers the simplest\nscenario, where alpha electrons pair with beta electrons as much as possible.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smi</strong>:  SMILES str or instance of rdkit.Chem.rdchem.Mol</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>(int, int). (net charge, all charge)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">smi</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator.Generator.smi_to_gjf", "modulename": "groupy.gp_generator", "qualname": "Generator.smi_to_gjf", "kind": "function", "doc": "<p>Generating a gjf file based on SMILES of molecule.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smi</strong>:  str. SMILES of a molecule.</li>\n<li><strong>nproc</strong>:  str or int. The number of CPU cores allowed for Gaussian to utilize. Default=12.</li>\n<li><strong>mem</strong>:  str. The amount of memory allocated for Gaussian to utilize. Default=12GB.</li>\n<li><strong>chk_path</strong>:  str. Path of chk file. Default={smi}.chk</li>\n<li><strong>gjf_path</strong>:  str. Path of gjf file you want to generate. Default={smi}.chk</li>\n<li><strong>gaussian_keywords</strong>:  str. Keywords in gjf fie. Default='#p opt freq b3lyp/6-31g*'</li>\n<li><strong>charge_and_multiplicity</strong>:  str. charge and multiplicity in gjf file. If set to None,\nGenerator will call Generator.calculate_charge() and\nGenerator.calculate_multiplicity() to calculate. example: '0 1'</li>\n<li><strong>add_other_tasks</strong>:  bool. Whether to add other job into you gjf file. Default=False</li>\n<li><strong>other_tasks</strong>:  list. Jobs you want to add into you gjf file. Default = ['#p m062x/def2tzvp geom=check',\n'#p m062x/def2tzvp scrf=solvent=water geom=check',]. Note that this parameter will only be used if add_other_tasks=True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>bool. True if the gjf file is successfully generated.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">smi</span>,</span><span class=\"param\">\t<span class=\"n\">nproc</span><span class=\"o\">=</span><span class=\"s1\">&#39;12&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mem</span><span class=\"o\">=</span><span class=\"s1\">&#39;12GB&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">chk_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gjf_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gaussian_keywords</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">charge_and_multiplicity</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">add_other_tasks</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">other_tasks</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator.Generator.batch_smi_to_gjf", "modulename": "groupy.gp_generator", "qualname": "Generator.batch_smi_to_gjf", "kind": "function", "doc": "<p>Generating some gjf files based on a file in which saved some SMILES.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  str. Path of the file in which saved SMILES.</li>\n<li><strong>gjf_root_path</strong>:  str. The folder path where all generated gjf files are saved.</li>\n<li><strong>nproc</strong>:  str or int. The number of CPU cores allowed for Gaussian to utilize. Default=12.</li>\n<li><strong>mem</strong>:  str. The amount of memory allocated for Gaussian to utilize. Default=12GB.</li>\n<li><strong>gaussian_keywords</strong>:  str. Keywords in gjf fie. Default='#p opt freq b3lyp/6-31g*'</li>\n<li><strong>charge_and_multiplicity</strong>:  str. charge and multiplicity in gjf file. If set to None,\nGenerator will call Generator.calculate_charge() and\nGenerator.calculate_multiplicity() to calculate. example: '0 1'</li>\n<li><strong>add_other_tasks</strong>:  bool. Whether to add other job into you gjf file. Default=False</li>\n<li><strong>other_tasks</strong>:  list. Jobs you want to add into you gjf file. Default = ['#p m062x/def2tzvp geom=check',\n'#p m062x/def2tzvp scrf=solvent=water geom=check',]. Note that this parameter will only be used if add_other_tasks=True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">smiles_file_path</span>,</span><span class=\"param\">\t<span class=\"n\">gjf_root_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nproc</span><span class=\"o\">=</span><span class=\"s1\">&#39;12&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mem</span><span class=\"o\">=</span><span class=\"s1\">&#39;12GB&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">gaussian_keywords</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">charge_and_multiplicity</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">add_other_tasks</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">other_tasks</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">index_start</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator.Generator.batch_smi_to_gjf_mpi", "modulename": "groupy.gp_generator", "qualname": "Generator.batch_smi_to_gjf_mpi", "kind": "function", "doc": "<p>Generating some gjf files based on a file in which saved some SMILES with MPI acceleration.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  str. Path of the file in which saved SMILES.</li>\n<li><strong>gjf_root_path</strong>:  str. The folder path where all generated gjf files are saved.</li>\n<li><strong>nproc</strong>:  str or int. The number of CPU cores allowed for Gaussian to utilize. Default=12.</li>\n<li><strong>mem</strong>:  str. The amount of memory allocated for Gaussian to utilize. Default=12GB.</li>\n<li><strong>gaussian_keywords</strong>:  str. Keywords in gjf fie. Default='#p opt freq b3lyp/6-31g*'</li>\n<li><strong>charge_and_multiplicity</strong>:  str. charge and multiplicity in gjf file. If set to None,\nGenerator will call Generator.calculate_charge() and\nGenerator.calculate_multiplicity() to calculate. example: '0 1'</li>\n<li><strong>add_other_tasks</strong>:  bool. Whether to add other job into you gjf file. Default=False</li>\n<li><strong>other_tasks</strong>:  list. Jobs you want to add into you gjf file. Default = ['#p m062x/def2tzvp geom=check',\n'#p m062x/def2tzvp scrf=solvent=water geom=check',]. Note that this parameter will only be used if add_other_tasks=True.</li>\n<li><strong>n_jobs</strong>:  int. number of CPU cores you want to use when generating gjf file.</li>\n<li><strong>batch_size</strong>:  int or str. Number of tasks per CPU core you want to use when generating gjf file. Default='auto'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">smiles_file_path</span>,</span><span class=\"param\">\t<span class=\"n\">gjf_root_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nproc</span><span class=\"o\">=</span><span class=\"s1\">&#39;12&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mem</span><span class=\"o\">=</span><span class=\"s1\">&#39;12GB&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">gaussian_keywords</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">charge_and_multiplicity</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">add_other_tasks</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">other_tasks</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">n_jobs</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator.Generator.write_gjf_link0_and_keyword", "modulename": "groupy.gp_generator", "qualname": "Generator.write_gjf_link0_and_keyword", "kind": "function", "doc": "<p>Only used in Generator.smi_to_gjf()</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gjf_path</span>,</span><span class=\"param\">\t<span class=\"n\">chk_path</span>,</span><span class=\"param\">\t<span class=\"n\">nproc</span>,</span><span class=\"param\">\t<span class=\"n\">mem</span>,</span><span class=\"param\">\t<span class=\"n\">gaussian_keywords</span>,</span><span class=\"param\">\t<span class=\"n\">charge_and_multiplicity</span>,</span><span class=\"param\">\t<span class=\"n\">note</span>,</span><span class=\"param\">\t<span class=\"n\">old_chk_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">add_link1</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator.Generator.write_gjf_coord", "modulename": "groupy.gp_generator", "qualname": "Generator.write_gjf_coord", "kind": "function", "doc": "<p>Only used in Generator.smi_to_gjf()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gjf_path</span>, </span><span class=\"param\"><span class=\"n\">xyz_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_generator.Generator.write_gjf_blank_line", "modulename": "groupy.gp_generator", "qualname": "Generator.write_gjf_blank_line", "kind": "function", "doc": "<p>Only used in Generator.smi_to_gjf()</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gjf_path</span>, </span><span class=\"param\"><span class=\"n\">blank_line_number</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_loader", "modulename": "groupy.gp_loader", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_loader.Loader", "modulename": "groupy.gp_loader", "qualname": "Loader", "kind": "class", "doc": "<p>A class for loading internal date of Groupy. Usually, users do not need to utilize this Python class.</p>\n"}, {"fullname": "groupy.gp_loader.Loader.parameters_path", "modulename": "groupy.gp_loader", "qualname": "Loader.parameters_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_loader.Loader.group_order_path", "modulename": "groupy.gp_loader", "qualname": "Loader.group_order_path", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_loader.Loader.load_parameters", "modulename": "groupy.gp_loader", "qualname": "Loader.load_parameters", "kind": "function", "doc": "<p>Loading parameters of group contribution method for groupy.gp_calculator.Calculator.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">parameter_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;simultaneous&#39;</span>, </span><span class=\"param\"><span class=\"n\">split</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_loader.Loader.load_group_order", "modulename": "groupy.gp_loader", "qualname": "Loader.load_group_order", "kind": "function", "doc": "<p>Loading order of group for groupy.gp_counter.Counter</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_tool", "modulename": "groupy.gp_tool", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_tool.Tool", "modulename": "groupy.gp_tool", "qualname": "Tool", "kind": "class", "doc": "<p>A class that implements some tools</p>\n"}, {"fullname": "groupy.gp_tool.Tool.load_smiles_iterator", "modulename": "groupy.gp_tool", "qualname": "Tool.load_smiles_iterator", "kind": "function", "doc": "<p>Load SMILES iterator based on file path.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>smiles_file_path</strong>:  Path of a file in which save some SMILES. (txt, xlsx, csv)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Iterator.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">smiles_file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_tool.export_a_dict", "modulename": "groupy.gp_tool", "qualname": "export_a_dict", "kind": "function", "doc": "<p>export a dict to .csv file</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>result_dict</strong>:  dict. The dictionary you want to export.</li>\n<li><strong>export_path</strong>:  Path of csv file you want to export.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">result_dict</span>, </span><span class=\"param\"><span class=\"n\">export_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;result.csv&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_tool.logo", "modulename": "groupy.gp_tool", "qualname": "logo", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;\\n---------------------------------------------------------------------------------\\nGroupy -- A Useful Tool for Molecular Analysis \\nDeveloper: Ruichen Liu\\nHint: Please feel easy to contact the developer if you have any problems in use.\\nE-mail1: liuruichen@tju.edu.cn\\nE-mail2: 1197748182@qq.com (may reply more quickly than E-mail1)\\n---------------------------------------------------------------------------------\\n&#x27;"}, {"fullname": "groupy.gp_viewer", "modulename": "groupy.gp_viewer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.gp_viewer.Viewer", "modulename": "groupy.gp_viewer", "qualname": "Viewer", "kind": "class", "doc": "<p>A class for visualizing SMILES and various chemical files. Users can call Viewer.plot_supported_format() to print\nall supported file formats.</p>\n"}, {"fullname": "groupy.gp_viewer.Viewer.view_mol", "modulename": "groupy.gp_viewer", "qualname": "Viewer.view_mol", "kind": "function", "doc": "<p>visualizing SMILES and various chemical files</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>mol</strong>:  str. SMILES of a molecule (at the same time, you have to set mol_type to be \"smi\").\nOr file path you want to view (at this time, you have to set mol_type to be the format of you file such as \"xyz\")</li>\n<li><strong>mol_type</strong>:  str.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">mol</span>, </span><span class=\"param\"><span class=\"n\">mol_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;smi&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.gp_viewer.Viewer.plot_supported_format", "modulename": "groupy.gp_viewer", "qualname": "Viewer.plot_supported_format", "kind": "function", "doc": "<p>print all supported file formats.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main", "modulename": "groupy.groupy_main", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "groupy.groupy_main.main_function_5", "modulename": "groupy.groupy_main", "qualname": "main_function_5", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_1_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_1_of_main_function_5", "kind": "function", "doc": "<ol>\n<li>generate a .xyz file by input SMILES of a molecule.</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_2_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_2_of_main_function_5", "kind": "function", "doc": "<ol start=\"2\">\n<li>generate a batch of .xyz files.</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_minus_2_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_minus_2_of_main_function_5", "kind": "function", "doc": "<ol start=\"2\">\n<li>generate a batch of .xyz files. use mpi</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_3_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_3_of_main_function_5", "kind": "function", "doc": "<ol start=\"3\">\n<li>convert a file to other format (e.g. xyz, mol, mol2, pdb...)</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_4_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_4_of_main_function_5", "kind": "function", "doc": "<ol start=\"4\">\n<li>convert a batch of file to other format.</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_minus_4_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_minus_4_of_main_function_5", "kind": "function", "doc": "<p>-4. convert a batch of file to other format. use mpi.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_5_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_5_of_main_function_5", "kind": "function", "doc": "<ol start=\"5\">\n<li>generate .gjf(input file of gaussian) file by input SMILES of a molecule.</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_6_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_6_of_main_function_5", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.sub_function_minus_6_of_main_function_5", "modulename": "groupy.groupy_main", "qualname": "sub_function_minus_6_of_main_function_5", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main_function_view", "modulename": "groupy.groupy_main", "qualname": "main_function_view", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main_function_1", "modulename": "groupy.groupy_main", "qualname": "main_function_1", "kind": "function", "doc": "<ol>\n<li>calculate properties of a molecule by input SMILES of this molecule.</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main_function_2", "modulename": "groupy.groupy_main", "qualname": "main_function_2", "kind": "function", "doc": "<ol start=\"2\">\n<li>count group number of a molecule by input SMILES of this molecule.</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main_function_3", "modulename": "groupy.groupy_main", "qualname": "main_function_3", "kind": "function", "doc": "<ol start=\"3\">\n<li>calculate properties of a batch of molecules by input filepath of a file in which save molecules (.txt, .csv, .xlsx).</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main_function_minus_3", "modulename": "groupy.groupy_main", "qualname": "main_function_minus_3", "kind": "function", "doc": "<p>-3. calculate properties of a batch of molecules by input filepath of a file in which save molecules (.txt, .csv, .xlsx).\nuse mpi</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main_function_4", "modulename": "groupy.groupy_main", "qualname": "main_function_4", "kind": "function", "doc": "<ol start=\"4\">\n<li>count group number of a batch of molecules by input filepath of a file in which save molecules (.txt, .csv, .xlsx).</li>\n</ol>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main_function_minus_4", "modulename": "groupy.groupy_main", "qualname": "main_function_minus_4", "kind": "function", "doc": "<p>-4. count group number of a batch of molecules by input filepath of a file in which save molecules (.txt, .csv, .xlsx).\nuse mpi</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "groupy.groupy_main.main", "modulename": "groupy.groupy_main", "qualname": "main", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();